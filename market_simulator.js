const fs = require('fs');
const csv = require('csv-parser');

// --- Сценарные параметры (можно менять для тестов) ---
// Параметр чувствительности рынка к качеству (из п. 49.2, формула 2)
const RP_PARAMETR_SA = 10;
// Порог сходимости как процент от общего спроса (0.01% по умолчанию)
const CONVERGENCE_THRESHOLD_PERCENT = 0.0001;
// Минимальное значение предложения для участия в распределении
const MIN_SUPPLY_FOR_DISTRIBUTION = 0.001;
// Объем мирового (внешнего) рынка теперь берётся из входных данных для каждой отрасли
// (строка с k==0 содержит спрос игрока "Мир"). Резервный/по умолчанию параметр можно задать
// через переменную окружения, но по умолчанию используем данные из CSV.

/**
 * Главная функция, запускающая симуляцию
 */
async function runSimulation() {
    try {
        // 1. Загружаем и парсим данные из CSV
        const allData = await loadDataFromCSV('input_data.csv');

        // 2. Группируем данные по отраслям, чтобы обрабатывать каждую отрасль отдельно
        const dataByIndustry = allData.reduce((acc, row) => {
            const industry = row.a;
            if (!acc[industry]) {
                acc[industry] = [];
            }
            acc[industry].push(row);
            return acc;
        }, {});

        console.log("--- СИМУЛЯЦИЯ РАСПРЕДЕЛЕНИЯ РЫНКА НАЧАТА ---\n");

        // 3. Запускаем симуляцию для каждой отрасли
        for (const industryId in dataByIndustry) {
            console.log(`
================== ОТРАСЛЬ: ${industryId} ==================`);
            const playersData = dataByIndustry[industryId];
            const results = simulateIndustryMarket(playersData);
            printResults(results, industryId);
        }

        console.log("\n--- СИМУЛЯЦИЯ ЗАВЕРШЕНА ---");

    } catch (error) {
        console.error("Произошла ошибка:", error);
    }
}

/**
 * Загружает и парсит данные из CSV файла
 * @param {string} filePath - Путь к CSV файлу
 * @returns {Promise<Array<Object>>} - Массив объектов с данными
 */
function loadDataFromCSV(filePath) {
    const data = [];
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (row) => {
                // Преобразуем строковые значения из CSV в числа
                for (const key in row) {
                    if (key !== 'a') { // 'a' - это строка (ID отрасли)
                        row[key] = parseFloat(row[key]);
                    }
                }
                data.push(row);
            })
            .on('end', () => {
                console.log('CSV файл успешно загружен.');
                resolve(data);
            })
            .on('error', (error) => reject(error));
    });
}

/**
 * Распределяет импорт между покупателями пропорционально их неудовлетворенному спросу
 * @param {Array<Object>} buyers - Массив покупателей (игроки с k !== 0)
 * @param {number} importAmount - Объем импорта для распределения
 */
function distributeImportToBuyers(buyers, importAmount) {
    const totalUnsatisfiedDemand = buyers.reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
    
    if (totalUnsatisfiedDemand > 0) {
        buyers.forEach(buyer => {
            const satisfactionShare = buyer.спрос_неудовлетворенный / totalUnsatisfiedDemand;
            const buyerImportAmount = importAmount * satisfactionShare;
            buyer.импорт_расчетный += buyerImportAmount;
            buyer.спрос_неудовлетворенный -= buyerImportAmount;
        });
    }
}

/**
 * Обрабатывает первую итерацию распределения спроса
 * @param {Array<Object>} playersData - Данные игроков
 * @param {number} общийСпрос - Общий внутренний спрос
 * @returns {number} - Суммарно удовлетворенный спрос на итерации
 */
function processFirstIteration(playersData, общийСпрос) {
    let суммарноУдовлетвореноНаИтерации = 0;
    const мир = playersData.find(p => p.k === 0);
    const buyers = playersData.filter(p => p.k !== 0);
    
    // Создаем матрицу продаж: кто сколько продал кому
    // salesMatrix[sellerK][buyerK] = объем продаж
    const salesMatrix = {};
    
    // Инициализируем матрицу
    playersData.forEach(seller => {
        salesMatrix[seller.k] = {};
        buyers.forEach(buyer => {
            salesMatrix[seller.k][buyer.k] = 0;
        });
    });

    // Распределяем спрос: каждый покупатель пытается купить у каждого продавца
    // пропорционально доле продавца
    buyers.forEach(buyer => {
        let остатокСпросаПокупателя = buyer.спрос_региона;
        
        playersData.forEach(seller => {
            // Сколько покупатель хочет купить у этого продавца
            const желаемаяПокупка = buyer.спрос_региона * seller.доля_идеал;
            // Сколько продавец может продать
            const доступноДляПродажи = Math.min(желаемаяПокупка, seller.предложение_остаток);
            // Сколько покупатель еще может купить
            const фактическаяПокупка = Math.min(доступноДляПродажи, остатокСпросаПокупателя);
            
            if (фактическаяПокупка > 0) {
                // Регистрируем продажу
                salesMatrix[seller.k][buyer.k] = фактическаяПокупка;
                
                // Обновляем состояние продавца
                seller.спрос_удовл_внутр += фактическаяПокупка;
                seller.предложение_остаток -= фактическаяПокупка;
                seller.потенциальный_внутренний_спрос += желаемаяПокупка;
                
                // Обновляем состояние покупателя
                остатокСпросаПокупателя -= фактическаяПокупка;
                
                // Если это покупка у "Мира", это импорт
                if (seller.k === 0) {
                    buyer.импорт_расчетный += фактическаяПокупка;
                }
                
                суммарноУдовлетвореноНаИтерации += фактическаяПокупка;
            }
        });
        
        // Обновляем неудовлетворенный спрос покупателя
        buyer.спрос_неудовлетворенный = остатокСпросаПокупателя;
    });
    
    // Добавляем потенциальный спрос для "Мира"
    if (мир) {
        мир.потенциальный_внутренний_спрос += общийСпрос * мир.доля_идеал;
    }

    return суммарноУдовлетвореноНаИтерации;
}

/**
 * Обрабатывает последующие итерации распределения спроса (2+)
 * @param {Array<Object>} playersData - Данные игроков  
 * @param {number} остатокСпроса - Остаток спроса для распределения
 * @returns {number} - Суммарно удовлетворенный спрос на итерации
 */
function processSubsequentIteration(playersData, остатокСпроса) {
    let суммарноУдовлетвореноНаИтерации = 0;
    const реальныеИгроки = playersData.filter(p => p.k !== 0);
    const buyers = playersData.filter(p => p.k !== 0);
    
    // Определяем доли только для реальных игроков с остатком предложения
    реальныеИгроки.forEach(p => {
        p.доля_tm_на_итерации = p.предложение_остаток > MIN_SUPPLY_FOR_DISTRIBUTION ? p.доля_идеал : 0;
    });
    
    const сумма_долей_tm_реальных = реальныеИгроки.reduce((sum, p) => sum + p.доля_tm_на_итерации, 0);

    if (сумма_долей_tm_реальных > 0) {
        // Распределяем между реальными игроками
        let salesInStep = 0;
        реальныеИгроки.forEach(seller => {
            const распределение_спроса = (seller.доля_tm_на_итерации / сумма_долей_tm_реальных) * остатокСпроса;
            seller.потенциальный_внутренний_спрос += распределение_спроса;
            const удовлНаИтерации = Math.min(распределение_спроса, seller.предложение_остаток);
            seller.спрос_удовл_внутр += удовлНаИтерации;
            seller.предложение_остаток -= удовлНаИтерации;
            salesInStep += удовлНаИтерации;
        });
        суммарноУдовлетвореноНаИтерации = salesInStep;

        // Обновляем неудовлетворенный спрос покупателей
        const totalUnsatisfiedDemand = buyers.reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
        if (totalUnsatisfiedDemand > 0) {
            buyers.forEach(buyer => {
                const satisfactionShare = buyer.спрос_неудовлетворенный / totalUnsatisfiedDemand;
                const satisfactionFromReal = salesInStep * satisfactionShare;
                buyer.спрос_неудовлетворенный -= satisfactionFromReal;
            });
        }
    } else {
        // Если у реальных игроков нет предложения, весь спрос идет к "Миру"
        const мир = playersData.find(p => p.k === 0);
        if (мир) {
            const удовлНаИтерации = Math.min(остатокСпроса, мир.предложение_остаток);
            мир.спрос_удовл_внутр += удовлНаИтерации;
            мир.предложение_остаток -= удовлНаИтерации;
            суммарноУдовлетвореноНаИтерации = удовлНаИтерации;

            // Распределяем импорт от мира
            distributeImportToBuyers(buyers, удовлНаИтерации);
        }
    }

    return суммарноУдовлетвореноНаИтерации;
}

/**
 * Основная функция, реализующая алгоритм распределения рынка для ОДНОЙ отрасли
 * @param {Array<Object>} playersData - Данные по всем игрокам для одной отрасли
 * @returns {Array<Object>} - Данные с добавленными результатами расчетов
 */
function simulateIndustryMarket(playersData) {
    const playerCount = playersData.filter(p => p.k !== 0).length;

    // --- ФАЗА 1: ПОДГОТОВКА И РАСЧЕТ НАЧАЛЬНЫХ ПАРАМЕТРОВ ---
    const общийСпрос = playersData
        .filter(p => p.k !== 0)
        .reduce((sum, p) => sum + p.спрос_региона, 0);

    // Расчет балла качества и идеальной доли для каждого игрока
    playersData.forEach(player => {
        // Начальное предложение: для "Мира" - весь внутренний спрос, для остальных - их валовой выпуск
        player.начальное_предложение = (player.k === 0) ? общийСпрос : player.валовой_выпуск;
        // Балл качества на основе уровня НТП (научно-технического прогресса)
        player.балл_са = player.начальное_предложение > 0 ? Math.exp(RP_PARAMETR_SA * player.уровень_нтп) : 0;
    });

    const суммаБалловСА = playersData.reduce((sum, p) => sum + p.балл_са, 0);
    playersData.forEach(player => {
        // Идеальная доля рынка на основе балла качества
        player.доля_идеал = суммаБалловСА > 0 ? player.балл_са / суммаБалловСА : 0;
    });

    // --- ФАЗА 2: ИТЕРАТИВНОЕ РАСПРЕДЕЛЕНИЕ ВНУТРЕННЕГО РЫНКА ---
    console.log(`
  === ФАЗА 2: Итеративное распределение (${playerCount} игроков) ===`);
    const фаза2НачалоВремени = Date.now();
    
    // Инициализация переменных для итеративного распределения
    playersData.forEach(player => {
        player.предложение_остаток = player.начальное_предложение;
        player.спрос_удовл_внутр = 0;
        player.потенциальный_внутренний_спрос = 0; // Накопительный потенциальный спрос
        if (player.k !== 0) {
            // Для реальных игроков
            player.спрос_неудовлетворенный = player.спрос_региона;
            player.импорт_расчетный = 0;
        } else {
            // Для "Мира" (внешний рынок)
            player.спрос_неудовлетворенный = 0;
            player.импорт_расчетный = 0;
        }
    });
    let спросОстатокНаРынке = общийСпрос;
    let выполненоИтераций = 0;
    let вышлиПоОстатку = false;
    let остатокПереданМиру = false;

    // Абсолютный порог сходимости для избежания излишних итераций с минимальными суммами
    const абсолютныйПорогСходимости = общийСпрос * CONVERGENCE_THRESHOLD_PERCENT;

    for (let m = 1; m <= playerCount + 1; m++) {
        выполненоИтераций = m;
        
        if (спросОстатокНаРынке <= абсолютныйПорогСходимости) {
            if (спросОстатокНаРынке > 0) {
                const мир = playersData.find(p => p.k === 0);
                if (мир) {
                    мир.спрос_удовл_внутр += спросОстатокНаРынке;
                    мир.предложение_остаток -= спросОстатокНаРынке;
                    остатокПереданМиру = true;

                    // Распределяем малый остаток импорта между покупателями
                    const buyers = playersData.filter(p => p.k !== 0);
                    distributeImportToBuyers(buyers, спросОстатокНаРынке);
                }
                спросОстатокНаРынке = 0;
            }
            вышлиПоОстатку = true;
            break;
        }

        let суммарноУдовлетвореноНаИтерации = 0;
        
        // Выполняем итерацию в зависимости от номера
        if (m === 1) {
            // Первая итерация: распределение по идеальным долям среди всех игроков
            console.log(`\n  --- Детали первой итерации ---`);
            const началоСпроса = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
            console.log(`  Неудовлетворенный спрос до итерации: ${началоСпроса.toFixed(2)}`);
            
            суммарноУдовлетвореноНаИтерации = processFirstIteration(playersData, общийСпрос);
            
            const конецСпроса = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
            const импортВсего = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.импорт_расчетный, 0);
            const мир = playersData.find(p => p.k === 0);
            console.log(`  Продажи "Мира" на итерации: ${мир ? мир.спрос_удовл_внутр.toFixed(2) : '0.00'}`);
            console.log(`  Импорт регионов (должен совпадать): ${импортВсего.toFixed(2)}`);
            console.log(`  Неудовлетворенный спрос после итерации: ${конецСпроса.toFixed(2)}`);
            console.log(`  Удовлетворено на итерации всего: ${суммарноУдовлетвореноНаИтерации.toFixed(2)}`);
            console.log(`  -------------------------------`);
        } else {
            // Последующие итерации: распределение остатка только среди реальных игроков с предложением
            суммарноУдовлетвореноНаИтерации = processSubsequentIteration(playersData, спросОстатокНаРынке);
        }
        
        спросОстатокНаРынке -= суммарноУдовлетвореноНаИтерации;
    }

    // Логирование результатов фазы 2
    const фаза2ВремяВыполнения = Date.now() - фаза2НачалоВремени;
    console.log(`  Итераций выполнено: ${выполненоИтераций} из ${playerCount + 1} максимум`);
    console.log(`  Время выполнения фазы 2: ${фаза2ВремяВыполнения}мс`);
    console.log(`  Остаток спроса после фазы 2: ${спросОстатокНаРынке.toFixed(6)}`);
    console.log(`  Порог сходимости: ${абсолютныйПорогСходимости.toFixed(6)} (${(CONVERGENCE_THRESHOLD_PERCENT * 100).toFixed(3)}% от общего спроса)`);
    if (остатокПереданМиру) {
        console.log(`  Малый остаток передан игроку "Мир"`);
    }
    console.log(`  Причина завершения: ${вышлиПоОстатку ? 'Спрос полностью распределён (с учетом порога)' : 'Достигнут максимум итераций'}`);
    console.log(`  Общий спрос был: ${общийСпрос.toFixed(2)}`);

    // --- ФАЗА 3: ВНЕШНИЙ РЫНОК И ПОДВЕДЕНИЕ ИТОГОВ ---
    
    // Шаг 12 и 13: Определение доступного объема мирового спроса.
    const мир = playersData.find(p => p.k === 0);
    const доступныйМировойСпрос = мир && isFinite(мир.спрос_региона) ? мир.спрос_региона : 0;
    if (!мир) console.warn('ВНИМАНИЕ: для отрасли не найден игрок с k==0 (Мир). Доступный мировой спрос будет 0.');

    // Шаг 14: Распределение потенциального внешнего спроса
    playersData.forEach(p => {
        p.распределение_спроса_внеш = доступныйМировойСпрос * p.доля_идеал;
    });

    // Шаг 16: Расчет удовлетворенного внешнего спроса
    playersData.forEach(p => {
        if (p.k === 0) {
            p.спрос_удовл_внеш = p.распределение_спроса_внеш;
        } else {
            p.спрос_удовл_внеш = Math.min(p.распределение_спроса_внеш, p.предложение_остаток);
        }
    });

    // Шаг 17: Расчет итогового распределения внешнего спроса (для k=0)
    if (мир) {
        const суммаВнешнихПродажРеальныхИгроков = playersData
            .filter(p => p.k !== 0)
            .reduce((sum, p) => sum + p.спрос_удовл_внеш, 0);
        
        мир.распределение_спроса_внеш_итог = Math.max(0, доступныйМировойСпрос - суммаВнешнихПродажРеальныхИгроков);
    }
    playersData.forEach(p => {
        if (p.k !== 0) {
            p.распределение_спроса_внеш_итог = p.спрос_удовл_внеш;
        }
    });

    // Шаг 18: Итоговый остаток от предложения
    playersData.forEach(p => {
        p.предложение_остаток_итог = Math.max(0, p.предложение_остаток - p.распределение_спроса_внеш_итог);
    });

    // Шаг 20: Экспорт
    playersData.forEach(p => {
        p.экспорт = p.распределение_спроса_внеш_итог;
    });

    // Шаг 15: Полный спрос реализованный (итоговые продажи) и потенциальный
    playersData.forEach(player => {
        // Реализованный спрос (фактические продажи в стране и на экспорт)
        player.полный_спрос = player.экспорт + player.спрос_удовл_внутр;

        // Потенциальный полный спрос (сколько мог бы продать при неограниченном предложении)
        const потенциальный_внешний_спрос = player.распределение_спроса_внеш;
        player.потенциальный_полный_спрос = player.потенциальный_внутренний_спрос + потенциальный_внешний_спрос;
    });

    // Шаг 19: Импорт
    playersData.forEach(p => {
        if (p.k !== 0) {
            p.импорт = p.импорт_расчетный;
        } else {
            p.импорт = 0;
        }
    });
    if (мир) {
        const суммаЭкспортаРегионов = playersData
            .filter(p => p.k !== 0)
            .reduce((sum, p) => sum + p.экспорт, 0);
        мир.импорт = суммаЭкспортаРегионов;
    }

    // --- Отладочная информация по балансу ---
    const суммаИмпортаРегионов = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.импорт, 0);
    
    if (мир) {
        console.log(`
  --- Отладочная информация по балансу ---
`);
        console.log(`  Продажи "Мира" на внутреннем рынке (Фаза 2): ${мир.спрос_удовл_внутр.toFixed(2)}`);
        console.log(`  Суммарный импорт регионов (из Фазы 2):       ${суммаИмпортаРегионов.toFixed(2)}`);
        console.log(`  Экспорт "Мира" на внешний рынок (Фаза 3):    ${мир.экспорт.toFixed(2)}`);
        const балансВнутрРынка = мир.спрос_удовл_внутр - суммаИмпортаРегионов;
        console.log(`  Баланс (Продажи мира внутр. - Сумма импорта): ${балансВнутрРынка.toFixed(4)}`);
        if (Math.abs(балансВнутрРынка) > 0.001) {
            console.warn(`  ВНИМАНИЕ: Обнаружен дисбаланс между продажами "Мира" на внутреннем рынке и импортом регионов!`);
        }
        console.log(`  ------------------------------------------`);
    }

    // Возвращаем результат
    return playersData;
}


/**
 * Выводит результаты в консоль в читаемом виде
 * @param {Array<Object>} results - Массив с результатами
 * @param {string} industryId - ID отрасли
 */
function printResults(results, industryId) {
    console.log(`--- Результаты для отрасли "${industryId}" ---`);
    // Для отладки: выводим начальное предложение игрока 'Мир' (если есть)
    const mir = results.find(p => p.k === 0);
    if (mir) {
        console.log(`Предложение игрока МИР (начальное): ${mir.начальное_предложение.toFixed(2)}`);
    } else {
        console.log('Предложение игрока МИР (начальное): —');
    }

    // Оставляем только ключевые итоговые показатели для наглядности.
    console.table(results.map(p => ({
        'Игрок (k)': p.k === 0 ? 'Мир' : p.k,
        'Продано Внутри': p.спрос_удовл_внутр.toFixed(2),
        'Балл СА': p.балл_са.toFixed(2),
        'Доля_И': (p.доля_идеал * 100).toFixed(2),
        'Экспорт': p.экспорт.toFixed(2),
        'Импорт': p.импорт.toFixed(2),
        'Реализованный спрос': p.полный_спрос.toFixed(2),
        'Потенцциальный спрос': p.потенциальный_полный_спрос.toFixed(2),
        'Предложение Остаток Итог': p.предложение_остаток_итог.toFixed(2)
    })));
}

// Запускаем симуляцию
runSimulation();
