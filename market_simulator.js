const fs = require('fs');
const csv = require('csv-parser');

// --- Сценарные параметры (можно менять для тестов) ---
// Параметр чувствительности рынка к качеству (из п. 49.2, формула 2)
const RP_PARAMETR_SA = 10;
// Порог сходимости как процент от общего спроса (0.01%)
const CONVERGENCE_THRESHOLD_PERCENT = 0.0001;
// Минимальное значение предложения для участия в распределении
const MIN_SUPPLY_FOR_DISTRIBUTION = 0.001;
// Объем мирового (внешнего) рынка тут берётся из входных данных для каждой отрасли, в полной реализации должен считаться
// (строка с k==0 содержит спрос игрока "Мир")

/**
 * Главная функция, запускающая симуляцию
 */
async function runSimulation() {
    try {
        // 1. Загружаем и парсим данные из CSV
        const allData = await loadDataFromCSV('input_data.csv');

        // 2. Группируем данные по отраслям, чтобы обрабатывать каждую отрасль отдельно
        const dataByIndustry = allData.reduce((acc, row) => {
            const industry = row.a;
            if (!acc[industry]) {
                acc[industry] = [];
            }
            acc[industry].push(row);
            return acc;
        }, {});

        console.log("--- СИМУЛЯЦИЯ РАСПРЕДЕЛЕНИЯ РЫНКА НАЧАТА ---\n");

        // 3. Запускаем симуляцию для каждой отрасли
        for (const industryId in dataByIndustry) {
            console.log(`
================== ОТРАСЛЬ: ${industryId} ==================`);
            const playersData = dataByIndustry[industryId];
            const results = simulateIndustryMarket(playersData, industryId);
            printResults(results, industryId);
        }

        console.log("\n--- СИМУЛЯЦИЯ ЗАВЕРШЕНА ---");

    } catch (error) {
        console.error("Произошла ошибка:", error);
    }
}

/**
 * Загружает и парсит данные из CSV файла
 * @param {string} filePath - Путь к CSV файлу
 * @returns {Promise<Array<Object>>} - Массив объектов с данными
 */
function loadDataFromCSV(filePath) {
    const data = [];
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (row) => {
                // Преобразуем строковые значения из CSV в числа
                for (const key in row) {
                    if (key !== 'a') { // 'a' - это строка (ID отрасли)
                        row[key] = parseFloat(row[key]);
                    }
                }
                data.push(row);
            })
            .on('end', () => {
                console.log('CSV файл успешно загружен.');
                resolve(data);
            })
            .on('error', (error) => reject(error));
    });
}

/**
 * Распределяет импорт между покупателями пропорционально их неудовлетворенному спросу
 * @param {Array<Object>} buyers - Массив покупателей (игроки с k !== 0)
 * @param {number} importAmount - Объем импорта для распределения
 */
function distributeImportToBuyers(buyers, importAmount) {
    const totalUnsatisfiedDemand = buyers.reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
    
    if (totalUnsatisfiedDemand > 0) {
        buyers.forEach(buyer => {
            const satisfactionShare = buyer.спрос_неудовлетворенный / totalUnsatisfiedDemand;
            const buyerImportAmount = importAmount * satisfactionShare;
            buyer.импорт_расчетный += buyerImportAmount;
            buyer.спрос_неудовлетворенный -= buyerImportAmount;
        });
    }
}


/**
 * Универсальная функция распределения спроса для любой итерации
 * @param {Array<Object>} playersData - Данные игроков  
 * @param {number} спросДляРаспределения - Спрос для распределения на итерации
 * @param {boolean} включатьМир - Включать ли "Мир" в распределение
 * @returns {number} - Суммарно удовлетворенный спрос на итерации
 */
function processIteration(playersData, спросДляРаспределения, включатьМир = false) {
    let суммарноУдовлетвореноНаИтерации = 0;
    const мир = playersData.find(p => p.k === 0);
    const buyers = playersData.filter(p => p.k !== 0);
    
    // Определяем продавцов для этой итерации
    let sellers;
    if (включатьМир) {
        // Первая итерация: все участвуют, но только если у них есть предложение
        sellers = playersData.filter(p => p.предложение_остаток > MIN_SUPPLY_FOR_DISTRIBUTION);
    } else {
        // Последующие итерации: только реальные игроки с остатком предложения
        sellers = playersData.filter(p => p.k !== 0 && p.предложение_остаток > MIN_SUPPLY_FOR_DISTRIBUTION);
        
        // Если у реальных игроков нет предложения, но у Мира есть - включаем Мир
        if (sellers.length === 0 && мир && мир.предложение_остаток > MIN_SUPPLY_FOR_DISTRIBUTION) {
            sellers = [мир];
        }
    }
    
    // Если нет продавцов, возвращаем 0
    if (sellers.length === 0) {
        return 0;
    }
    
    // На первой итерации НЕ пересчитываем доли - используем оригинальные идеальные доли
    // На последующих итерациях пересчитываем для активных продавцов
    const суммаДолей = включатьМир ? 1.0 : sellers.reduce((sum, s) => sum + s.доля_идеал, 0);
    
    // Распределяем спрос: каждый продавец продает свою идеальную долю
    sellers.forEach(seller => {
        // Сколько этот продавец должен продать согласно своей идеальной доле
        const идеальныеПродажи = включатьМир 
            ? спросДляРаспределения * seller.доля_идеал  // На первой итерации - строго идеальная доля
            : спросДляРаспределения * (seller.доля_идеал / суммаДолей);  // На последующих - пересчитанная доля
        
        // Сколько он может реально продать
        const доступноДляПродажи = Math.min(идеальныеПродажи, seller.предложение_остаток);
        
        
        if (доступноДляПродажи > 0) {
            // Распределяем продажи между покупателями пропорционально их неудовлетворенному спросу
            const общийНеудовлСпрос = buyers.reduce((sum, b) => sum + b.спрос_неудовлетворенный, 0);
            
            if (общийНеудовлСпрос > 0) {
                let остатокПродаж = доступноДляПродажи;
                
                buyers.forEach(buyer => {
                    if (остатокПродаж <= 0 || buyer.спрос_неудовлетворенный <= 0) return;
                    
                    // Доля покупателя в общем неудовлетворенном спросе
                    const доляПокупателя = buyer.спрос_неудовлетворенный / общийНеудовлСпрос;
                    
                    // Сколько этот покупатель должен купить у продавца
                    const желаемаяПокупка = доступноДляПродажи * доляПокупателя;
                    const фактическаяПокупка = Math.min(желаемаяПокупка, buyer.спрос_неудовлетворенный, остатокПродаж);
                    
                    if (фактическаяПокупка > 0) {
                        // Обновляем продавца
                        seller.спрос_удовл_внутр += фактическаяПокупка;
                        seller.предложение_остаток -= фактическаяПокупка;
                        остатокПродаж -= фактическаяПокупка;
                        
                        // Обновляем покупателя
                        buyer.спрос_неудовлетворенный -= фактическаяПокупка;
                        
                        // Если это покупка у "Мира", это импорт
                        if (seller.k === 0) {
                            buyer.импорт_расчетный += фактическаяПокупка;
                        }
                        
                        
                        суммарноУдовлетвореноНаИтерации += фактическаяПокупка;
                    }
                });
                
                // Обновляем потенциальный спрос для продавца
                // На первой итерации - оригинальная доля, на последующих - пересчитанная
                const потенциальныеПродажи = включатьМир 
                    ? спросДляРаспределения * seller.доля_идеал  // Первая итерация - оригинальная доля
                    : спросДляРаспределения * (seller.доля_идеал / суммаДолей);  // Последующие - пересчитанная доля
                seller.потенциальный_внутренний_спрос += потенциальныеПродажи;
            }
        }
    });
    
    // Обновляем потенциальный спрос для Мира, если он участвовал
    if (включатьМир && мир) {
        мир.потенциальный_внутренний_спрос += спросДляРаспределения * мир.доля_идеал;
    }

    return суммарноУдовлетвореноНаИтерации;
}

/**
 * Обрабатывает первую итерацию распределения спроса
 * @param {Array<Object>} playersData - Данные игроков
 * @param {number} общийСпрос - Общий внутренний спрос
 * @returns {number} - Суммарно удовлетворенный спрос на итерации
 */
function processFirstIteration(playersData, общийСпрос) {
    return processIteration(playersData, общийСпрос, true);
}

/**
 * Обрабатывает последующие итерации распределения спроса (2+)
 * @param {Array<Object>} playersData - Данные игроков  
 * @param {number} остатокСпроса - Остаток спроса для распределения
 * @returns {number} - Суммарно удовлетворенный спрос на итерации
 */
function processSubsequentIteration(playersData, остатокСпроса) {
    return processIteration(playersData, остатокСпроса, false);
}

/**
 * Основная функция, реализующая алгоритм распределения рынка для ОДНОЙ отрасли
 * @param {Array<Object>} playersData - Данные по всем игрокам для одной отрасли
 * @param {string} industryId - ID отрасли
 * @returns {Array<Object>} - Данные с добавленными результатами расчетов
 */
function simulateIndustryMarket(playersData, industryId) {
    const playerCount = playersData.filter(p => p.k !== 0).length;

    // --- ФАЗА 1: ПОДГОТОВКА И РАСЧЕТ НАЧАЛЬНЫХ ПАРАМЕТРОВ ---
    const общийСпрос = playersData
        .filter(p => p.k !== 0)
        .reduce((sum, p) => sum + p.спрос_региона, 0);

    // Расчет балла качества и идеальной доли для каждого игрока
    playersData.forEach(player => {
        // Начальное предложение: валовой выпуск для всех игроков
        if (player.k === 0) {
            // Для отрасли O (госуправление) Мир не может ничего предлагать
            if (industryId === 'O' || industryId === 'Government' || industryId === 'Госуправление') {
                player.начальное_предложение = 0;
                console.log(`  Отрасль ${industryId}: Мир не может предлагать госуслуги (предложение = 0)`);
            } else {
                // Мир может предложить объем равный общему спросу регионов
                player.начальное_предложение = общийСпрос;
            }
        } else {
            // Реальные игроки предлагают свой валовой выпуск
            player.начальное_предложение = player.валовой_выпуск;
        }
        // Балл качества на основе уровня НТП (научно-технического прогресса)
        player.балл_са = player.начальное_предложение > 0 ? Math.exp(RP_PARAMETR_SA * player.уровень_нтп) : 0;
    });

    const суммаБалловСА = playersData.reduce((sum, p) => sum + p.балл_са, 0);
    playersData.forEach(player => {
        // Идеальная доля рынка на основе балла качества
        player.доля_идеал = суммаБалловСА > 0 ? player.балл_са / суммаБалловСА : 0;
    });

    // --- ФАЗА 2: ИТЕРАТИВНОЕ РАСПРЕДЕЛЕНИЕ ВНУТРЕННЕГО РЫНКА ---
    console.log(`
  === ФАЗА 2: Итеративное распределение (${playerCount} игроков) ===`);
    const фаза2НачалоВремени = Date.now();
    
    // Инициализация переменных для итеративного распределения
    playersData.forEach(player => {
        player.предложение_остаток = player.начальное_предложение;
        player.спрос_удовл_внутр = 0;
        player.потенциальный_внутренний_спрос = 0; // Накопительный потенциальный спрос
        if (player.k !== 0) {
            // Для реальных игроков
            player.спрос_неудовлетворенный = player.спрос_региона;
            player.импорт_расчетный = 0;
        } else {
            // Для "Мира" (внешний рынок)
            player.спрос_неудовлетворенный = 0;
            player.импорт_расчетный = 0;
        }
    });
    let спросОстатокНаРынке = общийСпрос;
    let выполненоИтераций = 0;
    let вышлиПоОстатку = false;
    let остатокПереданМиру = false;

    // Абсолютный порог сходимости для избежания излишних итераций с минимальными суммами
    const абсолютныйПорогСходимости = общийСпрос * CONVERGENCE_THRESHOLD_PERCENT;

    for (let m = 1; m <= playerCount + 1; m++) {
        выполненоИтераций = m;
        
        if (спросОстатокНаРынке <= абсолютныйПорогСходимости) {
            if (спросОстатокНаРынке > 0) {
                const мир = playersData.find(p => p.k === 0);
                if (мир) {
                    мир.спрос_удовл_внутр += спросОстатокНаРынке;
                    мир.предложение_остаток -= спросОстатокНаРынке;
                    остатокПереданМиру = true;

                    // Распределяем малый остаток импорта между покупателями
                    const buyers = playersData.filter(p => p.k !== 0);
                    distributeImportToBuyers(buyers, спросОстатокНаРынке);
                }
                спросОстатокНаРынке = 0;
            }
            вышлиПоОстатку = true;
            break;
        }

        let суммарноУдовлетвореноНаИтерации = 0;
        
        // Детальный вывод для каждой итерации
        console.log(`\n  --- Итерация ${m} из ${playerCount + 1} ---`);
        const началоСпроса = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
        const мирПродажиДо = playersData.find(p => p.k === 0)?.спрос_удовл_внутр || 0;
        const импортДо = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.импорт_расчетный, 0);
        
        console.log(`  Остаток спроса на рынке: ${спросОстатокНаРынке.toFixed(2)}`);
        console.log(`  Неудовлетворенный спрос игроков: ${началоСпроса.toFixed(2)}`);
        
        // Выполняем итерацию в зависимости от номера
        if (m === 1) {
            // Первая итерация: распределение по идеальным долям среди всех игроков
            console.log(`  Тип: Распределение между ВСЕМИ игроками (включая "Мир")`);
            суммарноУдовлетвореноНаИтерации = processFirstIteration(playersData, общийСпрос);
        } else {
            // Последующие итерации: распределение остатка только среди реальных игроков с предложением
            console.log(`  Тип: Распределение только между реальными игроками`);
            суммарноУдовлетвореноНаИтерации = processSubsequentIteration(playersData, спросОстатокНаРынке);
        }
        
        const конецСпроса = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.спрос_неудовлетворенный, 0);
        const мир = playersData.find(p => p.k === 0);
        const мирПродажиПосле = мир?.спрос_удовл_внутр || 0;
        const мирПродажиНаИтерации = мирПродажиПосле - мирПродажиДо;
        const импортПосле = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.импорт_расчетный, 0);
        const импортНаИтерации = импортПосле - импортДо;
        
        console.log(`  Удовлетворено на итерации: ${суммарноУдовлетвореноНаИтерации.toFixed(2)}`);
        console.log(`  - Продажи "Мира": ${мирПродажиНаИтерации.toFixed(2)}`);
        console.log(`  - Продажи реальных игроков: ${(суммарноУдовлетвореноНаИтерации - мирПродажиНаИтерации).toFixed(2)}`);
        console.log(`  Импорт на итерации: ${импортНаИтерации.toFixed(2)} ${Math.abs(мирПродажиНаИтерации - импортНаИтерации) < 0.001 ? '✓' : '✗ ОШИБКА!'}`);
        console.log(`  Остаток неудовл. спроса: ${конецСпроса.toFixed(2)}`);
        
        // Вывод сравнения идеальных и фактических долей на первой итерации
        if (m === 1) {
            console.log(`  \n  Анализ первой итерации:`);
            console.log(`  Продано только то, что могли продать по идеальным долям:`);
            playersData.forEach(player => {
                const идеальнаяДоля = player.доля_идеал * 100;
                const идеальныеПродажи = общийСпрос * player.доля_идеал;
                const фактПродажи = player.спрос_удовл_внутр;
                const ограничен = фактПродажи < идеальныеПродажи - 0.01;
                console.log(`    Игрок ${player.k === 0 ? 'МИР' : player.k}: ` +
                    `доля=${идеальнаяДоля.toFixed(1)}%, ` +
                    `хотел=${идеальныеПродажи.toFixed(0)}, ` +
                    `продал=${фактПродажи.toFixed(0)}` +
                    (ограничен ? ' (ограничен предложением)' : ''));
            });
            const общиеПродажи = playersData.reduce((sum, p) => sum + p.спрос_удовл_внутр, 0);
            console.log(`  Итого продано на первой итерации: ${общиеПродажи.toFixed(0)} из ${общийСпрос}`);
        }
        
        console.log(`  -------------------------------`);
        
        спросОстатокНаРынке -= суммарноУдовлетвореноНаИтерации;
    }

    // Логирование результатов фазы 2
    const фаза2ВремяВыполнения = Date.now() - фаза2НачалоВремени;
    console.log(`  Итераций выполнено: ${выполненоИтераций} из ${playerCount + 1} максимум`);
    console.log(`  Время выполнения фазы 2: ${фаза2ВремяВыполнения}мс`);
    console.log(`  Остаток спроса после фазы 2: ${спросОстатокНаРынке.toFixed(6)}`);
    console.log(`  Порог сходимости: ${абсолютныйПорогСходимости.toFixed(6)} (${(CONVERGENCE_THRESHOLD_PERCENT * 100).toFixed(3)}% от общего спроса)`);
    if (остатокПереданМиру) {
        console.log(`  Малый остаток передан игроку "Мир"`);
    }
    console.log(`  Причина завершения: ${вышлиПоОстатку ? 'Спрос полностью распределён (с учетом порога)' : 'Достигнут максимум итераций'}`);
    console.log(`  Общий спрос был: ${общийСпрос.toFixed(2)}`);

    // --- ФАЗА 3: ВНЕШНИЙ РЫНОК И ПОДВЕДЕНИЕ ИТОГОВ ---
    
    // Шаг 12 и 13: Определение доступного объема мирового спроса.
    const мир = playersData.find(p => p.k === 0);
    const доступныйМировойСпрос = мир && isFinite(мир.спрос_региона) ? мир.спрос_региона : 0;
    if (!мир) console.warn('ВНИМАНИЕ: для отрасли не найден игрок с k==0 (Мир). Доступный мировой спрос будет 0.');

    // Шаг 14: Распределение потенциального внешнего спроса
    playersData.forEach(p => {
        p.распределение_спроса_внеш = доступныйМировойСпрос * p.доля_идеал;
    });

    // Шаг 16: Расчет удовлетворенного внешнего спроса
    playersData.forEach(p => {
        if (p.k === 0) {
            p.спрос_удовл_внеш = p.распределение_спроса_внеш;
        } else {
            p.спрос_удовл_внеш = Math.min(p.распределение_спроса_внеш, p.предложение_остаток);
        }
    });

    // Шаг 17: Расчет итогового распределения внешнего спроса (для k=0)
    if (мир) {
        const суммаВнешнихПродажРеальныхИгроков = playersData
            .filter(p => p.k !== 0)
            .reduce((sum, p) => sum + p.спрос_удовл_внеш, 0);
        
        мир.распределение_спроса_внеш_итог = Math.max(0, доступныйМировойСпрос - суммаВнешнихПродажРеальныхИгроков);
    }
    playersData.forEach(p => {
        if (p.k !== 0) {
            p.распределение_спроса_внеш_итог = p.спрос_удовл_внеш;
        }
    });

    // Шаг 18: Итоговый остаток от предложения
    playersData.forEach(p => {
        p.предложение_остаток_итог = Math.max(0, p.предложение_остаток - p.распределение_спроса_внеш_итог);
    });

    // Шаг 20: Экспорт
    playersData.forEach(p => {
        p.экспорт = p.распределение_спроса_внеш_итог;
    });

    // Шаг 15: Полный спрос реализованный (итоговые продажи) и потенциальный
    playersData.forEach(player => {
        // Реализованный спрос (фактические продажи в стране и на экспорт)
        player.полный_спрос = player.экспорт + player.спрос_удовл_внутр;

        // Потенциальный полный спрос (сколько мог бы продать при неограниченном предложении)
        const потенциальный_внешний_спрос = player.распределение_спроса_внеш;
        player.потенциальный_полный_спрос = player.потенциальный_внутренний_спрос + потенциальный_внешний_спрос;
    });

    // Шаг 19: Импорт
    playersData.forEach(p => {
        if (p.k !== 0) {
            p.импорт = p.импорт_расчетный;
        } else {
            p.импорт = 0;
        }
    });
    if (мир) {
        const суммаЭкспортаРегионов = playersData
            .filter(p => p.k !== 0)
            .reduce((sum, p) => sum + p.экспорт, 0);
        мир.импорт = суммаЭкспортаРегионов;
    }

    // --- Отладочная информация по балансу ---
    const суммаИмпортаРегионов = playersData.filter(p => p.k !== 0).reduce((sum, p) => sum + p.импорт, 0);
    
    if (мир) {
        console.log(`
  --- Отладочная информация по балансу ---
`);
        console.log(`  Продажи "Мира" на внутреннем рынке (Фаза 2): ${мир.спрос_удовл_внутр.toFixed(2)}`);
        console.log(`  Суммарный импорт регионов (из Фазы 2):       ${суммаИмпортаРегионов.toFixed(2)}`);
        console.log(`  Экспорт "Мира" на внешний рынок (Фаза 3):    ${мир.экспорт.toFixed(2)}`);
        const балансВнутрРынка = мир.спрос_удовл_внутр - суммаИмпортаРегионов;
        console.log(`  Баланс (Продажи мира внутр. - Сумма импорта): ${балансВнутрРынка.toFixed(4)}`);
        if (Math.abs(балансВнутрРынка) > 0.001) {
            console.warn(`  ВНИМАНИЕ: Обнаружен дисбаланс между продажами "Мира" на внутреннем рынке и импортом регионов!`);
        }
        console.log(`  ------------------------------------------`);
    }

    // Возвращаем результат
    return playersData;
}


/**
 * Выводит результаты в консоль в читаемом виде
 * @param {Array<Object>} results - Массив с результатами
 * @param {string} industryId - ID отрасли
 */
function printResults(results, industryId) {
    console.log(`--- Результаты для отрасли "${industryId}" ---`);
    // Для отладки: выводим начальное предложение игрока 'Мир' (если есть)
    const mir = results.find(p => p.k === 0);
    if (mir) {
        console.log(`Предложение игрока МИР (начальное): ${mir.начальное_предложение.toFixed(2)}`);
    } else {
        console.log('Предложение игрока МИР (начальное): —');
    }

    // Оставляем только ключевые итоговые показатели для наглядности.
    console.table(results.map(p => ({
        'Игрок (k)': p.k === 0 ? 'Мир' : p.k,
        'Предложение': p.начальное_предложение.toFixed(0),
        'Спрос Регион': p.спрос_региона.toFixed(0),
        'Продано Внутри': p.спрос_удовл_внутр.toFixed(0),
        'Балл СА': p.балл_са.toFixed(0),
        'Доля_И': (p.доля_идеал * 100).toFixed(2),
        'Экспорт': p.экспорт.toFixed(0),
        'Импорт': p.импорт.toFixed(0),
        'Реализованный спрос': p.полный_спрос.toFixed(0),
        'Потенцциальный спрос': p.потенциальный_полный_спрос.toFixed(0),
        'Предложение Остаток': p.предложение_остаток_итог.toFixed(0)
    })));
}

// Запускаем симуляцию
runSimulation();
