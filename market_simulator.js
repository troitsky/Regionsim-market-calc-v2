const fs = require('fs');
const csv = require('csv-parser');

// --- Сценарные параметры (можно менять для тестов) ---
// Параметр чувствительности рынка к качеству (из п. 49.2, формула 2)
const RP_PARAMETR_SA = 10;
// Порог сходимости как процент от общего спроса (0.01% по умолчанию)
const CONVERGENCE_THRESHOLD_PERCENT = 0.0001;
// Объем мирового (внешнего) рынка теперь берётся из входных данных для каждой отрасли
// (строка с k==0 содержит спрос игрока "Мир"). Резервный/по умолчанию параметр можно задать
// через переменную окружения, но по умолчанию используем данные из CSV.

/**
 * Главная функция, запускающая симуляцию
 */
async function runSimulation() {
    try {
        // 1. Загружаем и парсим данные из CSV
        const allData = await loadDataFromCSV('input_data.csv');

        // 2. Группируем данные по отраслям, чтобы обрабатывать каждую отрасль отдельно
        const dataByIndustry = allData.reduce((acc, row) => {
            const industry = row.a;
            if (!acc[industry]) {
                acc[industry] = [];
            }
            acc[industry].push(row);
            return acc;
        }, {});

        console.log("--- СИМУЛЯЦИЯ РАСПРЕДЕЛЕНИЯ РЫНКА НАЧАТА ---\n");

        // 3. Запускаем симуляцию для каждой отрасли
        for (const industryId in dataByIndustry) {
            console.log(`\n================== ОТРАСЛЬ: ${industryId} ==================`);
            const playersData = dataByIndustry[industryId];
            const results = simulateIndustryMarket(playersData);
            printResults(results, industryId);
        }

        console.log("\n--- СИМУЛЯЦИЯ ЗАВЕРШЕНА ---");

    } catch (error) {
        console.error("Произошла ошибка:", error);
    }
}

/**
 * Загружает и парсит данные из CSV файла
 * @param {string} filePath - Путь к CSV файлу
 * @returns {Promise<Array<Object>>} - Массив объектов с данными
 */
function loadDataFromCSV(filePath) {
    const data = [];
    return new Promise((resolve, reject) => {
        fs.createReadStream(filePath)
            .pipe(csv())
            .on('data', (row) => {
                // Преобразуем строковые значения из CSV в числа
                for (const key in row) {
                    if (key !== 'a') { // 'a' - это строка (ID отрасли)
                        row[key] = parseFloat(row[key]);
                    }
                }
                data.push(row);
            })
            .on('end', () => {
                console.log('CSV файл успешно загружен.');
                resolve(data);
            })
            .on('error', (error) => reject(error));
    });
}

/**
 * Основная функция, реализующая алгоритм распределения рынка для ОДНОЙ отрасли
 * @param {Array<Object>} playersData - Данные по всем игрокам для одной отрасли
 * @returns {Array<Object>} - Данные с добавленными результатами расчетов
 */
function simulateIndustryMarket(playersData) {
    const playerCount = playersData.filter(p => p.k !== 0).length;

    // --- ФАЗА 1: ПОДГОТОВКА И РАСЧЕТ НАЧАЛЬНЫХ ПАРАМЕТРОВ ---
    const общийСпрос = playersData
        .filter(p => p.k !== 0)
        .reduce((sum, p) => sum + p.спрос_региона, 0);

    playersData.forEach(p => {
        p.начальное_предложение = (p.k === 0) ? общийСпрос : p.валовой_выпуск;
        p.балл_са = p.начальное_предложение > 0 ? Math.exp(RP_PARAMETR_SA * p.уровень_нтп) : 0;
    });

    const суммаБалловСА = playersData.reduce((sum, p) => sum + p.балл_са, 0);
    playersData.forEach(p => {
        p.доля_идеал = суммаБалловСА > 0 ? p.балл_са / суммаБалловСА : 0;
    });

    // --- ФАЗА 2: ИТЕРАТИВНОЕ РАСПРЕДЕЛЕНИЕ ВНУТРЕННЕГО РЫНКА ---
    console.log(`\n  === ФАЗА 2: Итеративное распределение (${playerCount} игроков) ===`);
    const фаза2НачалоВремени = Date.now();
    
    playersData.forEach(p => {
        p.предложение_остаток = p.начальное_предложение;
        p.спрос_удовл_внутр = 0;
    });
    let спросОстатокНаРынке = общийСпрос;
    let выполненоИтераций = 0;
    let вышлиПоОстатку = false;
    let остатокПереданМиру = false;
    
    // Вычисляем абсолютный порог сходимости
    const абсолютныйПорогСходимости = общийСпрос * CONVERGENCE_THRESHOLD_PERCENT;

    for (let m = 1; m <= playerCount + 1; m++) {
        выполненоИтераций = m;
        
        // Проверяем порог сходимости
        if (спросОстатокНаРынке <= абсолютныйПорогСходимости) {
            // Передаем малый остаток игроку "Мир"
            if (спросОстатокНаРынке > 0) {
                const мир = playersData.find(p => p.k === 0);
                if (мир) {
                    мир.спрос_удовл_внутр += спросОстатокНаРынке;
                    мир.предложение_остаток -= спросОстатокНаРынке;
                    остатокПереданМиру = true;
                }
                спросОстатокНаРынке = 0;
            }
            вышлиПоОстатку = true;
            break;
        }

        // --- ЛОГИКА ДЛЯ ИТЕРАЦИИ 'm' ---
        let суммарноУдовлетвореноНаИтерации = 0;
        
        if (m === 1) {
            // Итерация 1: Начальное распределение. "Мир" участвует наравне со всеми.
            playersData.forEach(p => {
                const распределение_спроса = общийСпрос * p.доля_идеал;
                const удовлНаИтерации = Math.min(распределение_спроса, p.предложение_остаток);
                p.спрос_удовл_внутр += удовлНаИтерации;
                p.предложение_остаток -= удовлНаИтерации;
                суммарноУдовлетвореноНаИтерации += удовлНаИтерации;
            });
        } else {
            // Итерации m > 1: Перераспределение остатка (п.9)
            const остатокСпросаДляПерераспределения = спросОстатокНаРынке;

            // Определяем "Долю_tm" для реальных игроков
            const реальныеИгроки = playersData.filter(p => p.k !== 0);
            реальныеИгроки.forEach(p => {
                p.доля_tm_на_итерации = p.предложение_остаток > 0.001 ? p.доля_идеал : 0;
            });
            const сумма_долей_tm_реальных = реальныеИгроки.reduce((sum, p) => sum + p.доля_tm_на_итерации, 0);

            if (сумма_долей_tm_реальных > 0) {
                // Сценарий 1: Есть реальные игроки, которые еще могут продавать. "Мир" не участвует.
                реальныеИгроки.forEach(p => {
                    const распределение_спроса = (p.доля_tm_на_итерации / сумма_долей_tm_реальных) * остатокСпросаДляПерераспределения;
                    const удовлНаИтерации = Math.min(распределение_спроса, p.предложение_остаток);
                    p.спрос_удовл_внутр += удовлНаИтерации;
                    p.предложение_остаток -= удовлНаИтерации;
                    суммарноУдовлетвореноНаИтерации += удовлНаИтерации;
                });
            } else {
                // Сценарий 2: Все реальные игроки исчерпали товар. "Мир" забирает весь остаток.
                const мир = playersData.find(p => p.k === 0);
                if (мир) {
                    const удовлНаИтерации = Math.min(остатокСпросаДляПерераспределения, мир.предложение_остаток);
                    мир.спрос_удовл_внутр += удовлНаИтерации;
                    мир.предложение_остаток -= удовлНаИтерации;
                    суммарноУдовлетвореноНаИтерации += удовлНаИтерации;
                }
            }
        }
        
        спросОстатокНаРынке -= суммарноУдовлетвореноНаИтерации;
    }

    // Логирование результатов фазы 2
    const фаза2ВремяВыполнения = Date.now() - фаза2НачалоВремени;
    console.log(`  Итераций выполнено: ${выполненоИтераций} из ${playerCount + 1} максимум`);
    console.log(`  Время выполнения фазы 2: ${фаза2ВремяВыполнения}мс`);
    console.log(`  Остаток спроса после фазы 2: ${спросОстатокНаРынке.toFixed(6)}`);
    console.log(`  Порог сходимости: ${абсолютныйПорогСходимости.toFixed(6)} (${(CONVERGENCE_THRESHOLD_PERCENT * 100).toFixed(3)}% от общего спроса)`);
    if (остатокПереданМиру) {
        console.log(`  Малый остаток передан игроку "Мир"`);
    }
    console.log(`  Причина завершения: ${вышлиПоОстатку ? 'Спрос полностью распределён (с учетом порога)' : 'Достигнут максимум итераций'}`);
    console.log(`  Общий спрос был: ${общийСпрос.toFixed(2)}`);

    // --- ФАЗА 3: ВНЕШНИЙ РЫНОК И ПОДВЕДЕНИЕ ИТОГОВ ---
    
    // Шаг 12 и 13: Определение доступного объема мирового спроса.
    // Теперь берем объем мирового спроса из входных данных: строка с k==0 для данной отрасли должна содержать
    // значение спрос_региона, которое мы интерпретируем как доступный мировой (внешний) спрос для этой отрасли.
    const mirRow = playersData.find(p => p.k === 0);
    const доступныйМировойСпрос = mirRow && isFinite(mirRow.спрос_региона) ? mirRow.спрос_региона : 0;
    if (!mirRow) console.warn('ВНИМАНИЕ: для отрасли не найден игрок с k==0 (Мир). Доступный мировой спрос будет 0.');

    // Шаг 14: Распределение потенциального внешнего спроса
    playersData.forEach(p => {
        p.распределение_спроса_внеш = доступныйМировойСпрос * p.доля_идеал;
    });

    // Шаг 16: Расчет удовлетворенного внешнего спроса
    playersData.forEach(p => {
        // Для k=0 (Мир), он может удовлетворить любой спрос на него
        if (p.k === 0) {
            p.спрос_удовл_внеш = p.распределение_спроса_внеш;
        } else {
            // Для реальных игроков - минимум из того, что на них просят, и того, что у них осталось
            p.спрос_удовл_внеш = Math.min(p.распределение_спроса_внеш, p.предложение_остаток);
        }
    });

    // Шаг 17: Расчет итогового распределения внешнего спроса (для k=0)
    const мир = playersData.find(p => p.k === 0);
    if (мир) {
        const суммаВнешнихПродажРеальныхИгроков = playersData
            .filter(p => p.k !== 0)
            .reduce((sum, p) => sum + p.спрос_удовл_внеш, 0);
        
        // Итоговые продажи "Мира" на внешнем рынке = МировойСпрос - всё, что продали другие
        мир.распределение_спроса_внеш_итог = Math.max(0, доступныйМировойСпрос - суммаВнешнихПродажРеальныхИгроков);
    }
    // Для реальных игроков
    playersData.forEach(p => {
        if (p.k !== 0) {
            p.распределение_спроса_внеш_итог = p.спрос_удовл_внеш;
        }
    });

    // Шаг 18: Итоговый остаток от предложения
    playersData.forEach(p => {
        // Остаток на складе после ВСЕХ продаж
        p.предложение_остаток_итог = Math.max(0, p.предложение_остаток - p.распределение_спроса_внеш_итог);
    });

    // Шаг 20: Экспорт
    // Этот параметр по сути дублирует `распределение_спроса_внеш_итог`
    playersData.forEach(p => {
        p.экспорт = p.распределение_спроса_внеш_итог;
    });

    // Шаг 15: Полный спрос реализованный (итоговые продажи) и потенциальный
    playersData.forEach(p => {
        // Реализованный спрос (фактические продажи в стране и на экспорт)
        p.полный_спрос = p.экспорт + p.спрос_удовл_внутр;

        // Потенциальный внутренний спрос (то, что игрок получил бы на 1-й итерации без ограничений)
        const потенциальныйВнутреннийСпрос = общийСпрос * p.доля_идеал;

        // Потенциальный внешний спрос почситан ранее (то, что игрок получил бы на внешнем рынке без ограничений производства)
        // Суммарный потенциальный спрос на продукцию этого игрока
        p.потенциальный_полный_спрос = потенциальныйВнутреннийСпрос + p.распределение_спроса_внеш;
    });

    // Шаг 19: Импорт (переделал, сейчас не по формуле из документа, жду уточнения от Наташи, почему так странно реализована, а не как здесь)
    playersData.forEach(p => {
        if (p.k !== 0) {
            // Разница между тем, что регион хотел, и тем, что ему продали на внутреннем рынке
            p.импорт = Math.max(0, p.спрос_региона - p.спрос_удовл_внутр);
        } else {
            p.импорт = 0;
        }
    });

    // Возвращаем результат
    return playersData;
}


/**
 * Выводит результаты в консоль в читаемом виде
 * @param {Array<Object>} results - Массив с результатами
 * @param {string} industryId - ID отрасли
 */
function printResults(results, industryId) {
    console.log(`--- Результаты для отрасли "${industryId}" ---`);
    // Для отладки: выводим начальное предложение игрока 'Мир' (если есть)
    const mir = results.find(p => p.k === 0);
    if (mir) {
        console.log(`Предложение игрока МИР (начальное): ${mir.начальное_предложение.toFixed(2)}`);
    } else {
        console.log('Предложение игрока МИР (начальное): —');
    }

    // Оставляем только ключевые итоговые показатели для наглядности.
    console.table(results.map(p => ({
        'Игрок (k)': p.k === 0 ? 'Мир' : p.k,
        'Продано Внутри': p.спрос_удовл_внутр.toFixed(2),
        'Балл СА': p.балл_са.toFixed(2),
        'Доля_И': (p.доля_идеал * 100).toFixed(2),
        'Экспорт': p.экспорт.toFixed(2),
        'Импорт': p.импорт.toFixed(2),
        'Реализованный спрос': p.полный_спрос.toFixed(2),
        'Потенцциальный спрос': p.потенциальный_полный_спрос.toFixed(2),
        'Предложение Остаток Итог': p.предложение_остаток_итог.toFixed(2)
    })));
}

// Запускаем симуляцию
runSimulation();