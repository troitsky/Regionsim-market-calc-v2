# Структура кода market_simulator.js

## Основные улучшения после рефакторинга

### 1. Константы и настройки
- `RP_PARAMETR_SA` - параметр чувствительности рынка к качеству
- `CONVERGENCE_THRESHOLD_PERCENT` - порог сходимости (0.01% от общего спроса)
- `MIN_SUPPLY_FOR_DISTRIBUTION` - минимальное предложение для участия в распределении

### 2. Вспомогательные функции

#### `distributeImportToBuyers(buyers, importAmount)`
Распределяет импорт между покупателями пропорционально их неудовлетворенному спросу.
- Используется для избежания дублирования кода
- Вызывается в нескольких местах алгоритма

#### `processFirstIteration(playersData, общийСпрос)`
Обрабатывает первую итерацию распределения:
- Распределение по идеальным долям среди всех игроков (включая "Мир")
- Учет продаж от "Мира" как импорт
- Обновление неудовлетворенного спроса

#### `processSubsequentIteration(playersData, остатокСпроса)`  
Обрабатывает последующие итерации (2+):
- Распределение только среди реальных игроков с остатком предложения
- Если у реальных игроков нет предложения - весь спрос идет к "Миру"
- Автоматический расчет импорта

### 3. Основная функция `simulateIndustryMarket`

#### Фаза 1: Подготовка
- Расчет балла качества на основе уровня НТП
- Определение идеальной доли рынка
- Инициализация переменных

#### Фаза 2: Итеративное распределение
- Основной цикл с максимум (playerCount + 1) итерациями
- Абсолютный порог сходимости для оптимизации
- Накопление потенциального спроса на каждой итерации
- Отслеживание импорта в реальном времени

#### Фаза 3: Внешний рынок
- Распределение экспорта
- Финальные расчеты реализованного и потенциального спроса

### 4. Ключевые изменения

1. **Абсолютный порог сходимости**: Избегаем лишних итераций при минимальных остатках
2. **Отслеживание импорта**: Импорт рассчитывается сразу при распределении от "Мира"
3. **Потенциальный спрос**: Накапливается на каждой итерации для точного учета
4. **Модульность**: Логика разбита на отдельные функции для лучшей читаемости

### 5. Преимущества рефакторинга

- **Читаемость**: Код стал более структурированным и понятным
- **Поддерживаемость**: Легче вносить изменения в отдельные части алгоритма
- **Производительность**: Оптимизирован выход из цикла при достижении порога
- **Отладка**: Лучшее логирование и отслеживание состояния